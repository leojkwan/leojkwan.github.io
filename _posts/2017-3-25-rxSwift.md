---
layout: post
title: 'Living reactively in Swift before Rx and DisposeBags'
type: post
status: draft
categories:
tags:
- ios
- swift 3
- networking
---

You know RxSwift has hit the mainstream of iOS swift programming recently after a dedicated book about RxSwift gets published on <a href="https://store.raywenderlich.com/products/rxswift?_ga=2.96130460.1493240101.1493879651-1050811074.1485642105">Ray Wenderlich</a> … and I bought it :). 

When I started learning iOS programming 2 years ago, I was always intimidated by Reactive Cocoa. It's not a friendly sight of code when you see it for the first time. I remember thinking, 'we never learned this in class, run!' and never looking back, until recently when more resources/blogs about RxSwift became published and more companies began open sourcing their codebases which heavily involve RxSwift.

Since then, I’ve come to better appreciate a  ‘reactive’ style of programming. The results were immediate to me. I wrote less boilerplate Delegate/Protocol code. I don’t need to ever consider NotificationCenter(not that I used it much in the first place.) Most importantly, it helped reduce the cognitive load or keeping multiple states in my application, specifically in view controllers.

But I only recently started to use a full-fledged framework like RxSwift for enabling reactive-like programming. Before that, I relied on simple MVVM principles along with a native Swift Observable pattern I picked up from a popular Swift example project, <a href="https://github.com/JakeLin/SwiftWeather/blob/fbd206fd7cf22badb9c758fe1e88d684d65cfc6f/SwiftWeather/Observable.swift">SwiftWeather</a>.

```swift
class Observable1<T> {
  
  typealias Observer = (T) -> Void
  private(set) var observer: Observer?
  
  func observe(_ observer: Observer?) {
	self.observer = observer
  }
  
  var value: T {
	didSet {
	  observer?(value)
	}
  }
  
  init(_ v: T) {
	value = v
  }
}
```


I’d simply enclose a value in this class named ‘Observable’, and this object would take in one observer that subscribed to the wrapped value’s changes. 

The core line lies in the ‘value’ didSet method. Every time a value is set, the observer, which is a function that accepts the wrapped value’s type, gets called with the updated value.

```swift
var value: T {
	didSet {
	  observer?(value)
	}
}
```

There's really no magic to it; as another developer who realized this Observable/KVO pattern pointed out, <a href="http://blog.jaredsinclair.com/post/136419814560/imagining-a-first-party-swift-kvo-replacement">*It would follow all the existing rules of memory management and variable scope as any other closure*</a>

```swift
class ViewController: UIViewController {
  
  var currentWeather: Observable<Double> = Observable(50)
  
  override func viewDidLoad() {
    super.viewDidLoad()
   
    currentWeather.observe { (newPrice) in
      print("1. Updated Temperature: \(newPrice)")
    }
    
    currentWeather.value = 50 // 1. Updated Temperature: 50
    currentWeather.value = 51 // 1. Updated Temperature: 51
    currentWeather.value = 52 // 1. Updated Temperature: 52    
  }
}
```


---

Simple example, not **realistic**. In reality, I probably want multiple things subscribing to currentWeather's changes.

```swift
class ViewController: UIViewController {
  
  var currentWeather: Observable1<Int> = Observable1(50)
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    currentWeather.observe { (newPrice) in
      print("1. Updated Temperature: \(newPrice)")
    }
    
    // Added a second observer
    currentWeather.observe { (newPrice) in
      print("2. Updated Temperature: \(newPrice)")
    }
    
    // Added a third observer
    currentWeather.observe { (newPrice) in
      print("3. Updated Temperature: \(newPrice)")
    }
    
    currentWeather.value = 50 // 3. Updated Temperature: 50
    currentWeather.value = 51 // 3. Updated Temperature: 51
    currentWeather.value = 52 // 3. Updated Temperature: 52    
    
  }
}
```

Looks go-- ***Wait***. That's not right. I get print statements from only the third observer — what about the 1st and 2nd ones? 

Looking back at Observable, I see that observer is a single property; so every time `subscribe` get called on currentWeather, the last observer gets **written over** by the newly passed in one. 


### This is when things got difficult.


At first thought, the most practical thing to do in order for Observable to push changes to multiple observers is to change `observer: Observer<T>` to an `observers: [Observer<T>]`. Sounds like a quick and easy fix!

```swift
class Observable<T> {
  
  typealias Observer = (T) -> Void
  private(set) var observers: [Observer] = [] // change to an array

  func observe(_ observer: @escaping Observer) {
    // append observer to array
    observers.append(observer)
  }
  
  var value: T {
    didSet {
      // iterate over observers and call each closure newly set value
      observers.forEach({$0(value)})
    }
  }
  
  init(_ v: T) {
    value = v
  }
}
```


There. Now we should be able to notify every function/observer in our `observers` array.

```swift
currentWeather.observe { (newPrice) in
      print("1. Updated Temperature: \(newPrice)")
}
    
currentWeather.observe { (newPrice) in
      print("2. Updated Temperature: \(newPrice)")
}
    
currentWeather.observe { (newPrice) in
      print("3. Updated Temperature: \(newPrice)")
}
    
currentWeather.value = 51
currentWeather.value = 52
currentWeather.value = 53
// 1. Updated Temperature: 51
// 2. Updated Temperature: 51
// 3. Updated Temperature: 51
// 1. Updated Temperature: 52
// 2. Updated Temperature: 52
// 3. Updated Temperature: 52
// 1. Updated Temperature: 53
// 2. Updated Temperature: 53
// 3. Updated Temperature: 53

```
<br>
### Sweeeet.
![](https://media.giphy.com/media/l0HlCUPEhddvUuGsw/giphy.gif)
{: class="responsive-image" style="margin:0 auto;width:50%;" }

This is very similar to what RxSwift does with `subscribe(...)` and `Variable`.

```swift
import RxSwift

class ViewController: UIViewController {
  
  let disposeBag = DisposeBag()
  let names = Variable(["Leo"])

  override func viewDidLoad() {
	super.viewDidLoad()
	
	names.asObservable().subscribe { (updatedArray) in
	  print(updatedArray.element ?? "no element")
	}
	.addDisposableTo(disposeBag)
	
	names.value.append("John")
        // ["Leo"]
        // ["Leo", "John"]
  }
}
```


Now there’s one *clear* difference between my example and RxSwift's example of an Observable. That's the ‘DisposeBag’.

---

## Enter DisposeBag rabbit hole.
<br>

It was only after using my own Swift Observable implementation where I realized I was missing something critically important. 

The observers are never deallocated. If you are observing the weather in a detail view controller and pop back to the root view, the detail view controller should be deallocated, along with anything owned by that view controller.

<img src="https://s3-us-west-2.amazonaws.com/leojkwan/videos/rxSwift-memory-leak.gif" style="display:inline;margin:0 auto;width:100%;">


The problem with our Observable implementation is that we can add an observer but **we don't know how** to remove it when the closure associated object is deinitialized.

Jared brought up a great point about marking each observable with a token; that is, instead of an observables array, use a dictionary where each observe value's key is a randomized number that gets returned everytime a new observable is added.

That would be a viable implementation for our use case where our view controller deals with one observable. We can introduce the concept of a dispose bag in our detail weather view controller, and when the view controller gets deallocated, so will the disposebag, and we can delete all observers containing our disposebags set of tokens. In a larger scale application, this would not work because observers do not live in a shared pool of other observers pointing to a dereferencing object

That 



The Dispose Bag.


In future posts I’ll get into the many nuances of RxSwift, but let’s dive into what DisposeBag does and why it it very critical in writing an observable/key value pattern.
